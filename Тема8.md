Отчет по Теме №8 выполнила:
- Лубянских Елизавета Дмитриевна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

Работу проверили:
- к.э.н., доцент Панов М.А.

 ## Лабораторная работа №1
### Создайте класс “Car” с атрибутами производитель и модель. Создайте объект этого класса. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями.

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.make = make ##устанавливает атрибут make текущего объекта класса Car в значение make, переданное в __init__.
        self.model = model##устанавливает атрибут model текущего объекта класса Car в значение model, переданное в __init__.

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
```

### Результат.
![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/fdae1e8f-3838-49bb-9d46-e386d11c2de2)

## Выводы. Self — это ссылка на текущий экземпляр класса. Это способ обращения к атрибутам и методам класса изнутри самого класса.


 ## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.make = make ##устанавливает атрибут make текущего объекта класса Car в значение make, переданное в __init__.
        self.model = model##устанавливает атрибут model текущего объекта класса Car в значение model, переданное в __init__.

    def drive(self):##определяем функцию drive
        print(f"Driving the {self.make} {self.model}")##выводим на экран фразу

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
my_car.drive()##вызываем функцию drive
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/1c45d28b-8564-40b2-a1ac-5d85e871a4e6)


 ## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.make = make ##устанавливает атрибут make текущего объекта класса Car в значение make, переданное в __init__.
        self.model = model##устанавливает атрибут model текущего объекта класса Car в значение model, переданное в __init__.

    def drive(self):  ##определяем функцию drive
        print(f"Driving the {self.make} {self.model}")  ##выводим на экран фразу

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
my_car.drive()##вызываем функцию drive

class ElectricCar(Car): ## создаём класс ElectricCar, наследуемый от Car
    def __init__(self, make, model, battery_capacity): ##передаём три экземпляра класса, где make, model, battery_capacity - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        super().__init__(make, model) ##вызывает метод инициализации из родительского класса, чтобы его дополнить
        self.battery_capacity = battery_capacity##устанавливает атрибут battery_capacity текущего объекта класса Car в значение battery_capacity, переданное в __init__.

    def charge(self):##определяем функцию charge
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")##выводим на экран фразу

my_electric_car = ElectricCar("Tesla", "Model S", 75)##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
my_electric_car.drive()##вызываем функцию drive из класса ElectricCar
my_electric_car.charge()##вызываем функцию charge
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/71d0f7a2-62f0-4845-8025-6423289e0165)



 ## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self._make = make ##Защищённый атрибут
        self.__model = model##Приватный атрибут

    def drive(self):  ##определяем функцию drive
        print(f"Driving the {self._make} {self.__model}")  ##выводим на экран фразу

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
print(my_car._make)# Доступ к защищённому атрибуту
#print(my_car.__model) #Ошибка! Приватный атрибут не доступен
my_car.drive()##вызываем функцию drive
```

### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/304903a1-7483-4a10-853f-51b95e0d449b)



## Лабораторная работа №5
###  Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Shape: #создаём родительский класс Shape
    def area(self):# функция area с аргументом self, где self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса
        pass ##оператор pass - заглушка

class Rectanagle(Shape): #создаём класс  Rectanagle, наследуемый от Shape
    def __init__(self, width, height): #передаём три экземпляра класса. Метод init отвечает за инициализацию экземпляров класса,
        self.width = width #устанавливает атрибут width текущего объекта класса Rectnagle в значение width, переданное в __init__
        self.height = height#устанавливает атрибут height текущего объекта класса Rectnagle в значение height, переданное в __init__

    def area(self):
       return self.width * self.height #возвращаем текущие аргументы в функцию area

class Circle(Shape):  #создаём класс  Rectanagle, наследуемый от Shape
    def __init__(self, radius):#передаём два экземпляра класса. Метод init отвечает за инициализацию экземпляров класса,
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius#возвращаем текущие аргументы в функцию area

shapes = [Rectanagle(4, 5), Circle(3)]# создаём массив, помещаем туда круг и прямоугольник
for shape in shapes:# с помощью цикла for выводим их площади по очереди
    print(shape.area())
```

### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/930f7f53-b79a-43d8-8684-ff985f6dfddc)

## Самостоятельная работа №1
### Найдите в интернете любую статью (объем статьи не менее 200 слов), скопируйте ее содержимое в файл и напишите программу, которая считает количество слов в текстовом файле и определит самое часто встречающееся слово. Результатом выполнения задачи будет: скриншот файла со статьей, листинг кода, и вывод в консоль, в котором будет указана вся необходимая информация.
```python
from collections import Counter
import re

def read_file(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    return content

def count_words(text):
    words = re.findall(r'\b\w+\b', text.lower())
    return len(words)

def find_most_common_word(text):
    words = re.findall(r'\b\w+\b', text.lower())
    word_counts = Counter(words)
    most_common_word = word_counts.most_common(1)
    return most_common_word[0][0] if most_common_word else None


def main():
    file_path = 'input.txt' 
    article_content = read_file(file_path)

    word_count = count_words(article_content)
    most_common_word = find_most_common_word(article_content)

    print(f"Количество слов в статье: {word_count}")
    print(f"Самое часто встречающееся слово: {most_common_word}")


if __name__ == "__main__":
    main()
```
### Результат

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/df26aa16-5502-405b-b037-4a248f7f8ebb)


## Выводы.
Класс collections.Counter() предназначен для удобных и быстрых подсчетов количества появлений неизменяемых элементов в последовательностях. Нам он понадобится для подсчёта самого частого слова в статье. Содержание Модуль re (регулярные выражения) в Python предоставляет мощные инструменты для работы с большим текстом.
После того, как подключены все необходимые инструменты, мы можем приступить к чтению текстового файла input.txt с помощью функции "with open". 
#### Функция count_word считает количество слов в статье с помощью findall(), который возвращает все непересекающиеся совпадения шаблона в строке в виде списка.
#### Функция find_most_common_word ищет самое частое слово в нашем тексте. Здесь регулярное выражение re.findall() разделяет текст на слова.  Counter подсчитывает частоту каждого слова. Находит самое частое слово - most_common_word.
#### Функция main(), вызывает две, представленные выше. 


 ## Самостоятельная работа №2
### У вас появилась потребность в ведении книги расходов, посмотрев все существующие варианты вы пришли к выводу что вас ничего не устраивает и нужно все делать самому. Напишите программу для учета расходов. Программа должна позволять вводить информацию о расходах, сохранять ее в файл и выводить существующие данные в консоль. Ввод информации происходит через консоль. Результатом выполнения задачи будет: скриншот файла с учетом расходов, листинг кода, и вывод в консоль, с демонстрацией работоспособности программы.
```python
import json

def add_expense(expenses, category, amount):
    if category in expenses:
        expenses[category].append(amount)
    else:
        expenses[category] = [amount]

def save_expenses(expenses, file_name):
    with open(file_name, 'w') as file:
        json.dump(expenses, file)

def load_expenses(file_name):
    try:
        with open(file_name, 'r') as file:
            return json.load(file)
    except FileNotFoundError:
        return {}

def display_expenses(expenses):
    if not expenses:
        print("Нет сохраненных расходов.")
        return

    print("Существующие данные о расходах:")
    for category, amounts in expenses.items():
        total_amount = sum(amounts)
        print(f"{category}: {total_amount}")

def main():
    file_name = 'expenses.json'
    expenses = load_expenses(file_name)

    while True:
        print("\n1. Добавить расход")
        print("2. Показать все расходы")
        print("3. Выход")

        choice = input("Выберите действие (1/2/3): ")

        if choice == '1':
            category = input("Введите категорию расхода: ")
            amount = float(input("Введите сумму расхода: "))
            add_expense(expenses, category, amount)
            save_expenses(expenses, file_name)
            print("Расход добавлен.")

        elif choice == '2':
            display_expenses(expenses)

        elif choice == '3':
            print("Программа завершена.")
            break

        else:
            print("Некорректный ввод. Попробуйте снова.")

if __name__ == "__main__":
    main()
```
### Результат.
![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/9923ba9e-b21d-4ad3-8297-6b4b36f454a4)

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/6d3fc0a3-b3b3-44e7-aedb-53517ab1d98e)

## Выводы.
Эта программа позволяет добавлять расходы в разные категории, сохранять их в файл и выводить уже сохраненные данные. Программа сохраняет данные в файл expenses.json и выводит информацию о расходах в консоль.
У нас есть 4 вспомогательные функции, с помощью которых можно ввести нужную нам категорию (одежда, продукты и т.д.), записать данные в файл, прочитать данные из файла и вывести их на экран. Основная - main()  с помощью конструкции if-elif-else вызывает нужные нам функции.

## Самостоятельная работа №3
### Имеется файл input.txt с текстом на латинице. Напишите программу, которая выводит следующую статистику по тексту: количество букв латинского алфавита; число слов; число строк. 
#### •	Текст в файле: 
#### Beautiful is better than ugly. 
#### Explicit is better than implicit. 
#### Simple is better than complex.
#### Complex is better than complicated.
#### •	Ожидаемый результат: Input file contains:
#### 108 letters
#### 20 words
#### 4 lines

```python
def get_statistics(file_path):
    with open(file_path, 'r') as file:
        content = file.read()

    letter_count = sum(c.isalpha() and c.isascii() for c in content)
    word_count = len(content.split())
    line_count = content.count('\n') + 1

    return letter_count, word_count, line_count

def main():
    file_path = 'input.txt'

    try:
        letter_count, word_count, line_count = get_statistics(file_path)

        print(f"Input file contains:")
        print(f"{letter_count} letters")
        print(f"{word_count} words")
        print(f"{line_count} lines")

    except FileNotFoundError:
        print(f"File '{file_path}' not found.")

if __name__ == "__main__":
    main()
```
### Результат
![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/9cba9885-a3cc-4b97-ab9c-3f3fadbdb07f)

## Выводы. 
Функция open() открывает файл input.txt для чтения ('r'). "letter_count " - считает количество символов без пробелов, т.е. кол-во букв; "word_count" - кол-во слов; "line_count" - кол-во строк. Если же в файле не окажется никаких данных, программа выведет: "File input.txt not found."

## Самостоятельная работа №4
### Напишите программу, которая получает на вход предложение, выводит его в терминал, заменяя все запрещенные слова звездочками * (количество звездочек равно количеству букв в слове). Запрещенные слова, разделенные символом пробела, хранятся в текстовом файле input.txt. Все слова в этом файле записаны в нижнем регистре. Программа должна заменить запрещенные слова, где бы они ни встречались, даже в середине другого слова. Замена производится независимо от регистра: если файл input.txt содержит запрещенное слово exam, то слова exam, Exam, ExaM, EXAM и exAm должны быть заменены на ****.
### Запрещенные слова: hello email python the exam wor is
### Предложение для проверки: Hello, world! Python IS the programming language of thE future. My EMAIL is....PYTHON is awesome!!!!
### Ожидаемый результат: *****, ***ld! ****** ** *** programming language of *** future. My ***** **....****** ** awesome!!!!

```python
with open('input.txt', 'r') as file:
    forbidden_words = file.read().split()

def replace_forbidden_words(sentence, forbidden_words):
    modified_sentence = sentence
    for word in forbidden_words:
        # Замена слова в любом регистре
        modified_sentence = modified_sentence.replace(word, '*' * len(word), -1)
    return modified_sentence

input_sentence = "Hello, world! Python IS the programming language of thE future. My EMAIL is.... PYTHON is awesome!!!!"

result = replace_forbidden_words(input_sentence.lower(), forbidden_words)

# Вывод результата
print(result)
```
## Результат

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/299bb16c-4163-4e73-881a-9df04e493070)


## Выводы.
Данная проргамма позволяет заменять запрещённые слова на символы (зацензурить) следующим образом. 
#### В функции open() переменная forbidden_words считывает список запрещённых слов из файла. split() разделяет строоку на слова.
#### В функции replace_forbidden_words каждая буква запрещённого слова sentence, поступающего из предложения, заменяется на "*". Значения заменяет функция replace().

## Самостоятельная работа №5
### Самостоятельно придумайте и решите задачу, которая будет взаимодействовать с текстовым файлом.

```python
fi = open('input.txt', 'rt')
fo = open('out.txt', 'wt')
for s in fi:
 fo.write(s)
fi.close()
fo.close()
```
### Результат

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/e563fd39-36b8-477b-af21-571b356bbddd)


## Выводы. Задача: дан текстовый файл input.txt переписать его содержимое в файл out.txt. 
fi - открывает файл input.txt и считывает содержимое, fo - открывает файл out.txt для записи. В цикле for происходит перепись содержимого из одного файла в другой, после чего файлы закрываются.
