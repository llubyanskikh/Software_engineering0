Отчет по Теме №10 выполнила:
- Лубянских Елизавета Дмитриевна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

Работу проверили:
- к.э.н., доцент Панов М.А.

 ## Лабораторная работа №1
### Наверняка вы думаете, что декораторы – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то подумает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно тут к вам на помощь приходят декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программа не будет считать одни и те же значения, а просто “возьмёт их из этого декоратора”). Вам нужно написать программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи. P.S. при запуске без декоратора можете долго не ждать, для наглядности хватит 10 секунд ожидания.


```python
from functools import lru_cache

@lru_cache(None) #декоратор динамического программирования
def fibbonachi(n):
    if n== 0:
        return 0
    elif n == 1:
        return 1
    return fibbonachi(n-1) + fibbonachi(n-2)

if __name__ == '__main__':
    print(fibbonachi(100))
```

### Результат
![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/f76a33b6-b90b-481f-b198-b372188f09f0)

 ## Лабораторная работа №2
### Илья пишет свой сайт и ему необходимо сделать минимальную проверку ввода данных пользователя при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решил, что будет проверять правильность введённых данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130.
Причем заметьте, что неважно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.


```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func

@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")

if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Пётр', 138, 15, 48, 2)
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/25cb0fc1-96a7-41c1-b123-0607d43dc3d0)



 ## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.make = make ##устанавливает атрибут make текущего объекта класса Car в значение make, переданное в __init__.
        self.model = model##устанавливает атрибут model текущего объекта класса Car в значение model, переданное в __init__.

    def drive(self):  ##определяем функцию drive
        print(f"Driving the {self.make} {self.model}")  ##выводим на экран фразу

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
my_car.drive()##вызываем функцию drive

class ElectricCar(Car): ## создаём класс ElectricCar, наследуемый от Car
    def __init__(self, make, model, battery_capacity): ##передаём три экземпляра класса, где make, model, battery_capacity - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        super().__init__(make, model) ##вызывает метод инициализации из родительского класса, чтобы его дополнить
        self.battery_capacity = battery_capacity##устанавливает атрибут battery_capacity текущего объекта класса Car в значение battery_capacity, переданное в __init__.

    def charge(self):##определяем функцию charge
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")##выводим на экран фразу

my_electric_car = ElectricCar("Tesla", "Model S", 75)##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
my_electric_car.drive()##вызываем функцию drive из класса ElectricCar
my_electric_car.charge()##вызываем функцию charge
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/71d0f7a2-62f0-4845-8025-6423289e0165)



 ## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self._make = make ##Защищённый атрибут
        self.__model = model##Приватный атрибут

    def drive(self):  ##определяем функцию drive
        print(f"Driving the {self._make} {self.__model}")  ##выводим на экран фразу

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
print(my_car._make)# Доступ к защищённому атрибуту
#print(my_car.__model) #Ошибка! Приватный атрибут не доступен
my_car.drive()##вызываем функцию drive
```

### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/304903a1-7483-4a10-853f-51b95e0d449b)



## Лабораторная работа №5
###  Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Shape: #создаём родительский класс Shape
    def area(self):# функция area с аргументом self, где self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса
        pass ##оператор pass - заглушка

class Rectanagle(Shape): #создаём класс  Rectanagle, наследуемый от Shape
    def __init__(self, width, height): #передаём три экземпляра класса. Метод init отвечает за инициализацию экземпляров класса,
        self.width = width #устанавливает атрибут width текущего объекта класса Rectnagle в значение width, переданное в __init__
        self.height = height#устанавливает атрибут height текущего объекта класса Rectnagle в значение height, переданное в __init__

    def area(self):
       return self.width * self.height #возвращаем текущие аргументы в функцию area

class Circle(Shape):  #создаём класс  Rectanagle, наследуемый от Shape
    def __init__(self, radius):#передаём два экземпляра класса. Метод init отвечает за инициализацию экземпляров класса,
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius#возвращаем текущие аргументы в функцию area

shapes = [Rectanagle(4, 5), Circle(3)]# создаём массив, помещаем туда круг и прямоугольник
for shape in shapes:# с помощью цикла for выводим их площади по очереди
    print(shape.area())
```

### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/930f7f53-b79a-43d8-8684-ff985f6dfddc)

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Violin: ## создаём класс Скрипка
    def __init__(self, size, model, color, country): ##передаём объекты класса размер, модель, цвет, страна. Self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.size = size ##устанавливает атрибут размер текущего объекта класса Скрикпи в значение размер(size), переданное в __init__.
        self.model = model
        self.color = color
        self.country = country

my_violin = Violin("4/4", "Yamaha V3-SKA", "mahogany", "Japan")#передаём значения атрибутов
```
### Результат

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/8befa0a0-088a-4b58-9142-e86962260249)

## Выводы.
### Итак, Self — это ссылка на текущий экземпляр класса, способ обращения к атрибутам и методам класса изнутри самого класса. Методы - это функции, определённые внутри класса, которые могут выполнять операции с объектами и их атрибутами. Метод __init__ является инициализатором класса. 


 ## Самостоятельная работа №2
### У вас появилась потребность в ведении книги расходов, посмотрев все существующие варианты вы пришли к выводу что вас ничего не устраивает и нужно все делать самому. Напишите программу для учета расходов. Программа должна позволять вводить информацию о расходах, сохранять ее в файл и выводить существующие данные в консоль. Ввод информации происходит через консоль. Результатом выполнения задачи будет: скриншот файла с учетом расходов, листинг кода, и вывод в консоль, с демонстрацией работоспособности программы.
```python
class Violin: ## создаём класс Скрипка
    def __init__(self, size, model, color, country): ##передаём объекты класса размер, модель, цвет, страна. Self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.size = size ##устанавливает атрибут размер текущего объекта класса Скрикпи в значение размер(size), переданное в __init__.
        self.model = model
        self.color = color
        self.country = country

    def buy(self):#определяем функцию buy
        print(f"Buy a {self.size} {self.model} {self.color} violin from {self.country}")

my_violin = Violin("4/4", "Yamaha V3-SKA", "mahogany", "Japan")#передаём значения атрибутов
my_violin.buy()
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/47557185-dc1f-497a-beac-f591722c182d)


## Выводы.
### Атрибуты - это свойства или данные, хранящиеся внутри объекта. Данная порграмма представляет как можно передавать состояние объекта.

## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Violin: ## создаём класс Скрипка
    def __init__(self, size, model, color, country): ##передаём объекты класса размер, модель, цвет, страна. Self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.size = size ##устанавливает атрибут размер текущего объекта класса Скрикпи в значение размер(size), переданное в __init__.
        self.model = model
        self.color = color
        self.country = country

    def buy(self):#определяем функцию buy
        print(f"Buy a {self.size} {self.model} {self.color} violin from {self.country}")

my_violin = Violin("4/4", "Yamaha V3-SKA", "mahogany", "Japan")#передаём значения атрибутов
my_violin.buy()

class ElectroViolin(Violin):
    def __init__(self, size, model, color, country, battery):
        super().__init__(size, model, color, country)
        self.battery = battery

    def sell(self):
        print(f"Sell an electric violin {self.size} {self.model} {self.color} color from {self.country} with a {self.battery} W")
my_electro_violin = ElectroViolin("3/4", "Yamaha360", "white", "Japan", "1.5")
my_electro_violin.buy()
my_electro_violin.sell()
```
### Результат
![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/d69dc87a-9b88-4288-a37d-5c6cc84942dc)


## Выводы. 
### Эта программа отображает как можно создать новый класс с помощью наследования. Дочерний класс наследует атрибуты и методы у родительского, а также может определять свои.

## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

```python
class Violin: # создаём класс Скрипка
    def __init__(self, size, model): #передаём объекты класса размер, модель, цвет, страна. Self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.__size = size #защищённый атрибут
        self._model = model#приватный атрибут


    def buy(self):#определяем функцию buy
        print(f"Buy a {self.__size} {self._model} violin")

my_violin = Violin("4/4", "Yamaha V3-SKA")#передаём значения атрибутов
print(my_violin._model)
my_violin.buy()
```
## Результат

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/6a7d335c-555c-49b7-a140-ca88164d33e2)


## Выводы.
### Инкапсуляция - это механизм,позволяющий скрывать детали реализации класса и предоставлять только необходимый интерфейс для взаимодействия с объектами. Она достигается с помощью объявления атрибутов и методов класса как публичные, запрещённые или приватные. 

## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли

```python
class MusicalInstrument:
    def cost(self):
        pass

class Violin(MusicalInstrument):
    def __init__(self, quantity, price):
        self.quantity = quantity
        self.price = price

    def cost(self):
        return self.quantity * self.price

class Piano(MusicalInstrument):
    def __init__(self, quantity, price, delivery):
        self.quantity = quantity
        self.price = price
        self.delivery = delivery

    def cost(self):
        return self.quantity * self.price + self.delivery
instruments = [Violin(4, 25600), Piano(1, 48900, 3300)]# создаём массив
for instrument in instruments:# с помощью цикла for выводим их площади по очереди
    print(instrument.cost())
```
### Результат

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/646efa91-c575-471c-9af7-b2e5380ecc93)


## Выводы. 
### На примере этой прогрраммы можно рассмотреть полиморфизм. Создаётся класс MusicalInstrument, в котором содержится метод cost. Через него будут подсчитываться общие расходы. Далее мы создаём ещё два класса: скрипка(здесь указываем ссылку на текущий экземпляр и аргументы количества и стоимости) и фортепиано(то же самое + доставка). Создаём массив, считаем и выводим на экран.
### Итак, полиморфизм позво
