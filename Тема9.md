Отчет по Теме №9 выполнила:
- Лубянских Елизавета Дмитриевна
- ПИЭ-21-2

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

Работу проверили:
- к.э.н., доцент Панов М.А.

 ## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию init (), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.

```python
class Ivan:
    __slots__ = ['name']

    def __init__(self, name):
        if name =='Иван':
            self.name = f"да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"

person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)

person2.surname = 'Петров'
```

### Результат.
![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/c90f43a3-1aa0-4a02-bac8-01ab650defb9)

 ## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.


```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None

    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print('Обычное мороженое')

icecream = Icecream()
icecream.composition()
icecream = Icecream('шоколадом')
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/40535671-b8fd-42da-b341-89e1b33d605b)

 ## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
Также вас необходимо объяснить Пете почему на скриншоте ниже в консоли выводится ошибка.

```python
class MyClass:
    def __init__(self, value):
        self._value = value

    def set_value(self, value):#установка значения атрибута
        self._value = value

    def get_value(self):#получение значения артибута
        return self._value

    def del_value(self):#удаление атрибута
        del self._value

    value = property(get_value, set_value, del_value, "Свойство value")

obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/d6fe8b75-e631-4198-96a4-df11c8061579)

## Выводы.
### Выводится ошибка, т.к. "_value" - режим доступа protected (служит для обращения внутри класса и во всех его дочерних классах).

 ## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.


```python
class Mammal:
    className = 'Mammal'

class Dog(Mammal):
    species = 'canine'
    sounds = 'wow'

class Cat(Mammal):
    species = 'feline'
    sounds = 'meow'

dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
 
```

### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/f278d19d-5ca1-4c6f-8622-ba8adc3d9761)

## Лабораторная работа №5
###  На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются.
Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.


```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет")

class English:
    @staticmethod
    def greeting():
        print("Hello")

def greet(language):
    language.greeting()

ivan = Russian()
greet(ivan)
john = English()
greet(john)
    print(shape.area())
```

### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/19830f98-aa4c-486b-bccc-33838d530d1c)


## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
```python
class Ivan:
    __slots__ = ['name']

    def __init__(self, name):
        if name =='Иван':
            self.name = f"да, я {name}"
        else:
            self.name = f"Я не {name}, а Иван"

person1 = Ivan('Алексей')
person2 = Ivan('Иван')
print(person1.name)
print(person2.name)

person2.surname = 'Петров'
```
### Результат

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/8befa0a0-088a-4b58-9142-e86962260249)

## Выводы.
### Итак, Self — это ссылка на теку

## Выводы. 
### Self — это ссылка на текущий экземпляр класса. Это способ обращения к атрибутам и методам класса изнутри самого класса.


 ## Лабораторная работа №2
### Дополните код из первого задания, добавив в него атрибуты и методы класса, заставьте машину “поехать”. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.make = make ##устанавливает атрибут make текущего объекта класса Car в значение make, переданное в __init__.
        self.model = model##устанавливает атрибут model текущего объекта класса Car в значение model, переданное в __init__.

    def drive(self):##определяем функцию drive
        print(f"Driving the {self.make} {self.model}")##выводим на экран фразу

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
my_car.drive()##вызываем функцию drive
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/1c45d28b-8564-40b2-a1ac-5d85e871a4e6)


 ## Лабораторная работа №3
### Создайте новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи. Реализуйте его наследование от класса, созданного в первом задании. Заставьте машину поехать, а потом заряжаться. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self.make = make ##устанавливает атрибут make текущего объекта класса Car в значение make, переданное в __init__.
        self.model = model##устанавливает атрибут model текущего объекта класса Car в значение model, переданное в __init__.

    def drive(self):  ##определяем функцию drive
        print(f"Driving the {self.make} {self.model}")  ##выводим на экран фразу

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
my_car.drive()##вызываем функцию drive

class ElectricCar(Car): ## создаём класс ElectricCar, наследуемый от Car
    def __init__(self, make, model, battery_capacity): ##передаём три экземпляра класса, где make, model, battery_capacity - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        super().__init__(make, model) ##вызывает метод инициализации из родительского класса, чтобы его дополнить
        self.battery_capacity = battery_capacity##устанавливает атрибут battery_capacity текущего объекта класса Car в значение battery_capacity, переданное в __init__.

    def charge(self):##определяем функцию charge
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")##выводим на экран фразу

my_electric_car = ElectricCar("Tesla", "Model S", 75)##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
my_electric_car.drive()##вызываем функцию drive из класса ElectricCar
my_electric_car.charge()##вызываем функцию charge
```
### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/71d0f7a2-62f0-4845-8025-6423289e0165)



 ## Лабораторная работа №4
### Реализуйте инкапсуляцию для класса, созданного в первом задании. Создайте защищенный атрибут производителя и приватный атрибут модели. Вызовите защищенный атрибут и заставьте машину поехать. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Car: ## создаём класс Car
    def __init__(self, make, model): ##передаём три экземпляра класса, где make и model - это значения, которые передаются при создании нового объекта класса Car, а self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса. Метод init отвечает за инициализацию экземпляров класса,
        self._make = make ##Защищённый атрибут
        self.__model = model##Приватный атрибут

    def drive(self):  ##определяем функцию drive
        print(f"Driving the {self._make} {self.__model}")  ##выводим на экран фразу

my_car = Car("Toyota", "Corolla")##self не передается при создании нового объекта класса. Python автоматически передает ссылку на текущий объект в self.
print(my_car._make)# Доступ к защищённому атрибуту
#print(my_car.__model) #Ошибка! Приватный атрибут не доступен
my_car.drive()##вызываем функцию drive
```

### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/304903a1-7483-4a10-853f-51b95e0d449b)



## Лабораторная работа №5
###  Реализуйте полиморфизм создав основной (общий) класс “Shape”, а также еще два класса “Rectangle” и “Circle”. Внутри последних двух классов реализуйте методы для подсчета площади фигуры. После этого создайте массив с фигурами, поместите туда круг и прямоугольник, затем при помощи цикла выведите их площади. Напишите комментарии для кода, объясняющие его работу. Результатом выполнения задания будет листинг кода с комментариями и получившийся вывод в консоль.

```python
class Shape: #создаём родительский класс Shape
    def area(self):# функция area с аргументом self, где self - специальный параметр, который передается первым аргументом в метод класса и представляет собой ссылку на экземпляр класса
        pass ##оператор pass - заглушка

class Rectanagle(Shape): #создаём класс  Rectanagle, наследуемый от Shape
    def __init__(self, width, height): #передаём три экземпляра класса. Метод init отвечает за инициализацию экземпляров класса,
        self.width = width #устанавливает атрибут width текущего объекта класса Rectnagle в значение width, переданное в __init__
        self.height = height#устанавливает атрибут height текущего объекта класса Rectnagle в значение height, переданное в __init__

    def area(self):
       return self.width * self.height #возвращаем текущие аргументы в функцию area

class Circle(Shape):  #создаём класс  Rectanagle, наследуемый от Shape
    def __init__(self, radius):#передаём два экземпляра класса. Метод init отвечает за инициализацию экземпляров класса,
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius#возвращаем текущие аргументы в функцию area

shapes = [Rectanagle(4, 5), Circle(3)]# создаём массив, помещаем туда круг и прямоугольник
for shape in shapes:# с помощью цикла for выводим их площади по очереди
    print(shape.area())
```

### Результат.

![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/930f7f53-b79a-43d8-8684-ff985f6dfddc)

## Задания для самостоятельного выполнения:
Задание Садовник и помидоры.
Классовая структура:
Есть Помидор со следующими характеристиками:
•	Индекс
•	Стадия созревания (стадии: отсутствует, цветение, зеленый, красный)
Помидор может:
•	Расти (переходить на следующую стадию созревания)
•	Предоставлять информацию о своей зрелости

Есть Куст с помидорами, который:
•	Содержит список томатов, которые на нем растут А также может:
•	Расти вместе с томатами
•	Предоставлять информацию о зрелости всех томатов
•	Предоставлять урожай

И также есть Садовник, который имеет:
•	Имя
•	Растение, за которым он ухаживает Он может:
•	Ухаживать за растением
•	Собирать с него урожай

### Класс Tomato:
1)	Создайте класс Tomato
2)	Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3)	Создайте метод	init	(), внутри которого будут определены два динамических свойства: _index (передается параметром) и _state
 
(принимает первое значение из словаря states). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
4)	Создайте метод grow(), который будет переводить томат на следующую стадию созревания
5)	Создайте метод is_ripe(), который будет проверять, что томат созрел 

```python
class Tomato:
    # Статическое свойство states, содержащее все стадии созревания помидора
    states = ["отсутствует", "цветение", "зеленый", "красный"]

    def __init__(self, index):
        # Динамическое свойство _index, переданное параметром
        self._index = index
        # Динамическое свойство _state, принимает первое значение из словаря states
        self._state = self.states[0]

    def grow(self):
        # Метод перевода томата на следующую стадию созревания
        if self._state != self.states[-1]:
            current_index = self.states.index(self._state)
            self._state = self.states[current_index + 1]

    def is_ripe(self):
        # Метод проверки зрелости томата
        return self._state == self.states[-1]
```
### Класс TomatoBush:
1)	Создайте класс TomatoBush
2)	Определите метод	init	(), который будет принимать в качестве параметра количество томатов и на его основе будет создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes
3)	Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4)	Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми.
5)	Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая
```python
class TomatoBush:
    def __init__(self, num_tomatoes):
        # Динамическое свойство tomatoes, содержащее список объектов класса Tomato
        self.tomatoes = [Tomato(index) for index in range(1, num_tomatoes + 1)]

    def grow_all(self):
        # Метод перевода всех томатов на следующий этап созревания
        for tomato in self.tomatoes:
            tomato.grow()

    def all_are_ripe(self):
        # Метод проверки, все ли томаты из списка стали спелыми
        return all(tomato.is_ripe() for tomato in self.tomatoes)

    def give_away_all(self):
        # Метод очистки списка томатов после сбора урожая
        self.tomatoes = []
```
### Класс Gardener:
1)	Создайте класс Gardener
2)	Создайте метод	init	(), внутри которого будут определены два динамических свойства: name (передается параметром, является публичным) и _plant (принимает объект класса TomatoBush). После написания этого блока кода в комментарии к нему укажите какими являются эти два свойства
3)	Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4)	Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все, то садовник собирает урожай. Если нет, то метод печатает предупреждение
5)	Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству

```python
class Gardener:
    def __init__(self, name, plant):
        # Динамическое свойство name, переданное параметром, является публичным
        self.name = name
        # Динамическое свойство _plant, принимает объект класса TomatoBush
        self._plant = plant

    def work(self):
        # Метод, заставляющий садовника работать, что позволяет растению становиться более зрелым
        self._plant.grow_all()

    def harvest(self):
        # Метод проверки зрелости всех плодов и сбора урожая
        if self._plant.all_are_ripe():
            print(f"{self.name} собрал урожай!")
            self._plant.give_away_all()
        else:
            print("Плоды еще не все созрели. Подождите немного.")

    @staticmethod
    def knowledge_base():
        # Статический метод вывода справки по садоводству
        print("Садоводство - это искусство выращивания растений в саду.")
```

### Тесты:
1)	Вызовите справку по садоводству
2)	Создайте объекты классов TomatoBush и Gardener
3)	Используя объект класса Gardener, поухаживайте за кустом с помидорами
4)	Попробуйте собрать урожай, когда томаты еще не дозрели. Продолжайте ухаживать за ними
5)	Соберите урожай


```python
# Вызов справки по садоводству
Gardener.knowledge_base()

# Создание объектов классов TomatoBush и Gardener
tomato_bush = TomatoBush(num_tomatoes=5)
gardener = Gardener(name="John", plant=tomato_bush)

# Уход за кустом с помидорами
gardener.work()  # Растение становится более зрелым

# Попытка собрать урожай, когда томаты еще не дозрели
gardener.harvest()  # Плоды еще не все созрели. Подождите немного.

# Продолжение ухода за растением
gardener.work()  # Растение становится еще более зрелым
gardener.work()  # Растение становится еще более зрелым

# Попытка снова собрать урожай
gardener.harvest()  # John собрал урожай!
```
## Результаты
![image](https://github.com/llubyanskikh/Software_engineering0/assets/147454826/27639b9c-c537-4110-99f6-d3269f3208c0)

## Выводы
### Эта прграмма образовывает структуру классов процесса выращивания помидоров.

Класс Tomato представляет отдельный помидор с определенными характеристиками, такими как индекс и стадия созревания.
Реализованы методы для перехода на следующую стадию созревания (grow) и проверки зрелости (is_ripe).

TomatoBush class:
Класс TomatoBush моделирует куст с группой помидоров.
Использует список объектов класса Tomato для представления помидоров на кусте.
Реализованы методы для перевода всех помидоров на следующий этап созревания (grow_all), проверки зрелости всех плодов (all_are_ripe), и сбора урожая (give_away_all).

Gardener class:
Класс Gardener представляет садовника, который ухаживает за растением.
Метод work позволяет садовнику ухаживать за растением, вызывая его рост.
Метод harvest проверяет зрелость плодов и, если все помидоры спелые, собирает урожай.

Программа демонстрирует использование классов, методов, свойств и статических методов для моделирования процесса выращивания и ухода за растением в контексте садоводства.

